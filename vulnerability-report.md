#Vulnerability Report

**A1 - Injection**

Since the upload function takes in a request argument, doing some validation on the request.user.is_authenticated, request.user.username, and request.user.id objects would probably be pretty helpful. Alienation and cleansing of the entered data would also be helpful. Parsing it for terms, especially SQL query calls (FROM, SELECT, DROP, *, TABLE) would also be helpful to securing the form.

Or you could just do what the solution says and instantiate a new File class instead of using the curs.execute method at all. 

The site seems really secure seeing as I couldn't even figure out how to upload a task until about 30 minutes in.

```Python
def upload(request, project_id):

    bad_words = ['FROM', 'SELECT', 'DROP', '*', 'TABLE']

    if request.method == 'POST' and request.user.is_authenticated:

        proj = Project.objects.get(pk=project_id)
        form = ProjectFileForm(request.POST, request.FILES)

        if form.is_valid() and request.user:
            name = request.POST.get('name', False)
            upload_path = store_uploaded_file(name, request.FILES['file'])
            
            #A1 - Injection (SQLi)

            check = name.split()
            for item in check:
                if item in bad_words:
                    return HTTPResponseNotFound("You killed me, Jim! Actually you tried to SQL inject us, but we caught you.")

            curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))

            # file = File(
            #name = name,
            #path = upload_path,
            # project = proj)

            # file.save()

            return redirect('/taskManager/' + project_id +
                            '/', {'new_file_added': True})
        else:
            form = ProjectFileForm()
    else:
        form = ProjectFileForm()
    return render_to_response(
        'taskManager/upload.html', {'form': form}, RequestContext(request))
```


**A2**

Would never have guessed this one. It makes sense though. Seems like a Django responsibility and maybe should be highlighted in the docs. Better to explicitly include what you need than explicitly exclude what you do not. 

```
class UserForm(forms.ModelForm):
    """ User registration form """

    class Meta:
        model = User
        # exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']

        fields = ['username', 'first_name', 'last_name', 'email', 'password']
```

**A3**

I assume this has something to do with implementing the {% csrf_token %} within the html and enabling csrf in the settings. 
Not really sure how to exploit these attacks really, but I don't know why one would put the csrf_exempt wrapper on something as sensitive as login, reset password, profile by id, etc. Those have been removed.

**A4**

Put in authorization and permission checks on sensitive functions, especially anything that deletes. Again, maybe this seems so simple because you already taught us this, but like why would a developer assume their users are anything but idiots or attackers? I get that being lazy is generally a good quality to have, but leaving out security is not lazy, it's dumb and could end up costing the developer their job/client.

CHeck for permissions on sensitive functions.